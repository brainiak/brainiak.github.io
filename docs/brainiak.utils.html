<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>brainiak.utils package &mdash; brainiak 0.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Contributing" href="contributing.html" />
    <link rel="prev" title="brainiak.searchlight package" href="brainiak.searchlight.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            brainiak
          </a>
              <div class="version">
                0.12
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">brainiak</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="api.html">API</a></li>
          <li class="breadcrumb-item"><a href="brainiak.html">brainiak package</a></li>
      <li class="breadcrumb-item active">brainiak.utils package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/brainiak.utils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="module-brainiak.utils">
<span id="brainiak-utils-package"></span><h1>brainiak.utils package<a class="headerlink" href="#module-brainiak.utils" title="Permalink to this heading"></a></h1>
<p>Utilities used by multiple subpackages.</p>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="module-brainiak.utils.fmrisim">
<span id="brainiak-utils-fmrisim-module"></span><h2>brainiak.utils.fmrisim module<a class="headerlink" href="#module-brainiak.utils.fmrisim" title="Permalink to this heading"></a></h2>
<p>fMRI Simulator</p>
<p>Simulate fMRI data for a single subject.</p>
<p>This code provides a set of functions necessary to produce realistic
simulations of fMRI data. There are two main steps: characterizing the
signal and generating the noise model, which are then combined to simulate
brain data. Tools are included to support the creation of different types
of signal, such as region specific differences in univariate
activity. To create the noise model the parameters can either be set
manually or can be estimated from real fMRI data with reasonable accuracy (
works best when fMRI data has not been preprocessed)</p>
<p>Functions:</p>
<p>generate_signal
Create a volume with activity, of a specified shape and either multivariate
or univariate pattern, in a specific region to represent the signal in the
neural data.</p>
<p>generate_stimfunction
Create a timecourse of the signal activation. This can be specified using event
onsets and durations from a timing file. This is the time course before
convolution and therefore can be at any temporal precision.</p>
<p>export_3_column:
Generate a three column timing file that can be used with software like FSL
to represent event event onsets and duration</p>
<p>export_epoch_file:
Generate an epoch file from the time course which can be used as an input to
brainiak functions</p>
<p>convolve_hrf
Convolve the signal timecourse with the  HRF to model the expected evoked
activity</p>
<p>apply_signal
Combine the signal volume with the HRF, thus giving the signal the temporal
properties of the HRF (such as smoothing and lag)</p>
<p>calc_noise
Estimate the noise properties of a given fMRI volume. Prominently, estimate
the smoothing and SFNR of the data</p>
<p>generate_noise
Create the noise for this run. This creates temporal, spatial task and white
noise. Various parameters can be tuned depending on need</p>
<p>mask_brain
Create a mask volume that has similar contrast as an fMRI image. Defaults to
use an MNI grey matter atlas but any image can be supplied to create an
estimate.</p>
<p>compute_signal_change
Convert the signal function into useful metric units according to metrics
used by others (Welvaert &amp; Rosseel, 2013)</p>
<blockquote>
<div><p>Authors:
Cameron Ellis (Princeton &amp; Yale) 2016-2018
Chris Baldassano (Princeton) 2016-2017
Mingbo Cai (Princeton) 2017</p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.apply_signal">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">apply_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume_signal</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.apply_signal" title="Permalink to this definition"></a></dt>
<dd><p>Combine the signal volume with its timecourse</p>
<p>Apply the convolution of the HRF and stimulus time course to the
volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_function</strong> (<em>timepoint by timecourse array</em><em>, </em><em>float</em>) – The timecourse of the signal over time. If there is only one column
then the same timecourse is applied to all non-zero voxels in
volume_signal. If there is more than one column then each column is
paired with a non-zero voxel in the volume_signal (a 3d numpy array
generated in generate_signal).</p></li>
<li><p><strong>volume_signal</strong> (<em>multi dimensional array</em><em>, </em><em>float</em>) – The volume containing the signal to be convolved with the same
dimensions as the output volume. The elements in volume_signal
indicate how strong each signal in signal_function are modulated by
in the output volume</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signal</strong> – The convolved signal volume with the same 3d as volume signal and
the same 4th dimension as signal_function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>multidimensional array, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.calc_noise">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">calc_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.calc_noise" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the noise properties of the volume supplied.
This estimates what noise properties the volume has. For instance it
determines the spatial smoothness, the autoregressive noise, system
noise etc. Read the doc string for generate_noise to understand how
these different types of noise interact.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volume</strong> (<em>4d numpy array</em><em>, </em><em>float</em>) – Take in a functional volume (either the file name or the numpy
array) to be used to estimate the noise properties of this</p></li>
<li><p><strong>mask</strong> (<em>3d numpy array</em><em>, </em><em>binary</em>) – A binary mask of the brain, the same size as the volume</p></li>
<li><p><strong>template</strong> (<em>3d array</em><em>, </em><em>float</em>) – A continuous (0 -&gt; 1) volume describing the likelihood a voxel is in
the brain. This can be used to contrast the brain and non brain.</p></li>
<li><p><strong>noise_dict</strong> (<em>dict</em>) – The initialized dictionary of the calculated noise parameters of the
provided dataset (usually it is only the voxel size)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>noise_dict</strong> – Return a dictionary of the calculated noise parameters of the provided
dataset</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.compute_signal_change">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">compute_signal_change</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnitude</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'PSC'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.compute_signal_change" title="Permalink to this definition"></a></dt>
<dd><p>Rescale the signal to be a given magnitude, based on a specified
metric (e.g. percent signal change). Metrics are heavily inspired by
Welvaert &amp; Rosseel (2013). The rescaling is based on the maximal
activity in the timecourse. Importantly, all values within the
signal_function are scaled to have a min of -1 or max of 1, meaning that
the voxel value will be the same as the magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>signal_function</strong> (<em>timepoint by voxel array</em>) – The signal time course to be altered. This can have
multiple time courses specified as different columns in this
array. Conceivably you could use the output of
generate_stimfunction as the input but the temporal variance
will be incorrect. Critically, different values across voxels are
considered relative to each other, not independently. E.g., if the
voxel has a peak signal twice as high as another voxel’s, then this
means that the signal after these transformations will still be
twice as high (according to the metric) in the first voxel relative
to the second</p></li>
<li><p><strong>noise_function</strong> (<em>timepoint by voxel numpy array</em>) – The time course of noise (a voxel created from generate_noise)
for each voxel specified in signal_function. This is necessary
for computing the mean evoked activity and the noise variability</p></li>
<li><p><strong>noise_dict</strong> (<em>dict</em>) – <p>A dictionary specifying the types of noise in this experiment. The
noise types interact in important ways. First, autoregressive,
physiological and task-based noise types are mixed together in
_generate_temporal_noise. The parameter values for ‘auto_reg_sigma’,
‘physiological_sigma’ and ‘task_sigma’ describe the proportion of
mixing of these elements, respectively. However critically, ‘SFNR’ is
the parameter that controls how much noise these components contribute
to the brain. ‘auto_reg_rho’ and ‘ma_rho’ set parameters for the
autoregressive noise being simulated. Second, drift noise is added to
this, according to the size of ‘drift_sigma’. Thirdly, system noise is
added based on the ‘SNR’ parameter. Finally, ‘fwhm’ is used to estimate
the smoothness of the noise being inserted. If ‘matched’ is set to
true, then it will fit the parameters to match the participant as best
as possible.</p>
<p>Variables defined as follows:</p>
<p>snr [float]: Ratio of MR signal to the spatial noise
sfnr [float]: Ratio of the MR signal to the temporal noise. This is the
total variability that the following sigmas ‘sum’ to:</p>
<p>task_sigma [float]: Size of the variance of task specific noise
auto_reg_sigma [float]: Size of the variance of autoregressive
noise. This is an ARMA process where the AR and MA components can be
separately specified
physiological_sigma [float]: Size of the variance of physiological
noise</p>
<p>drift_sigma [float]: Size of the variance of drift noise</p>
<p>auto_reg_rho [list]: The coefficients of the autoregressive
components you are modeling
ma_rho [list]:The coefficients of the moving average components you
are modeling
max_activity [float]: The max value of the averaged brain in order
to reference the template
voxel_size [list]: The mm size of the voxels
fwhm [float]: The gaussian smoothing kernel size (mm)
matched [bool]: Specify whether you are fitting the noise parameters</p>
<p>The volumes of brain noise that are generated have smoothness
specified by ‘fwhm’</p>
</p></li>
<li><p><strong>magnitude</strong> (<em>list</em><em> of </em><em>floats</em>) – This specifies the size, in terms of the metric choosen below,
of the signal being generated. This can be a single number,
and thus apply to all signal timecourses, or it can be array and
thus different for each voxel.</p></li>
<li><p><strong>method</strong> (<em>str</em>) – Select the procedure used to calculate the signal magnitude,
some of which are based on the definitions outlined in Welvaert &amp;
Rosseel (2013):
- ‘SFNR’: Change proportional to the temporal variability,
as represented by the (desired) SFNR
- ‘CNR_Amp/Noise-SD’: Signal magnitude relative to the temporal
noise
- ‘CNR_Amp2/Noise-Var_dB’: Same as above but converted to decibels
- ‘CNR_Signal-SD/Noise-SD’: Standard deviation in signal
relative to standard deviation in noise
- ‘CNR_Signal-Var/Noise-Var_dB’: Same as above but converted to
decibels
- ‘PSC’: Calculate the percent signal change based on the
average activity of the noise (mean / 100 * magnitude)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signal_function_scaled</strong> – The new signal volume with the appropriately set signal change</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>4d numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.convolve_hrf">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">convolve_hrf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stimfunction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hrf_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'double_gamma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.convolve_hrf" title="Permalink to this definition"></a></dt>
<dd><p>Convolve the specified hrf with the timecourse.
The output of this is a downsampled convolution of the stimfunction and
the HRF function. If temporal_resolution is 1 / tr_duration then the
output will be the same length as stimfunction. This time course assumes
that slice time correction has occurred and all slices have been aligned
to the middle time point in the TR.</p>
<p>Be aware that if scaling is on and event durations are less than the
duration of a TR then the hrf may or may not come out as anticipated.
This is because very short events would evoke a small absolute response
after convolution  but if there are only short events and you scale then
this will look similar to a convolution with longer events. In general
scaling is useful, which is why it is the default, but be aware of this
edge case and if it is a concern, set the scale_function to false.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stimfunction</strong> (<em>timepoint by feature array</em>) – What is the time course of events to be modelled in this
experiment. This can specify one or more timecourses of events.
The events can be weighted or binary</p></li>
<li><p><strong>tr_duration</strong> (<em>float</em>) – How long (in s) between each volume onset</p></li>
<li><p><strong>hrf_type</strong> (<em>str</em><em> or </em><em>list</em>) – Takes in a string describing the hrf that ought to be created.
Can instead take in a vector describing the HRF as it was
specified by any function. The default is ‘double_gamma’ in which
an initial rise and an undershoot are modelled.</p></li>
<li><p><strong>scale_function</strong> (<em>bool</em>) – Do you want to scale the function to a range of 1</p></li>
<li><p><strong>temporal_resolution</strong> (<em>float</em>) – How many elements per second are you modeling for the stimfunction</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>signal_function</strong> – The time course of the HRF convolved with the stimulus function.
This can have multiple time courses specified as different
columns in this array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>timepoint by timecourse array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.export_3_column">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">export_3_column</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stimfunction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.export_3_column" title="Permalink to this definition"></a></dt>
<dd><p>Output a tab separated three column timing file</p>
<p>This produces a three column tab separated text file, with the three
columns representing onset time (s), event duration (s) and weight,
respectively. Useful if you want to run the simulated data through FEAT
analyses. In a way, this is the reverse of generate_stimfunction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stimfunction</strong> (<em>timepoint by 1 array</em>) – The stimulus function describing the time course of events. For
instance output from generate_stimfunction.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – The name of the three column text file to be output</p></li>
<li><p><strong>temporal_resolution</strong> (<em>float</em>) – How many elements per second are you modeling with the
stimfunction?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.export_epoch_file">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">export_epoch_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stimfunction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.export_epoch_file" title="Permalink to this definition"></a></dt>
<dd><p>Output an epoch file, necessary for some inputs into brainiak</p>
<p>This takes in the time course of stimulus events and outputs the epoch
file used in Brainiak. The epoch file is a way to structure the timing
information in fMRI that allows you to flexibly input different stimulus
sequences. This is a list with each entry a 3d matrix corresponding to a
participant. The dimensions of the 3d matrix are condition by epoch by
time. For the i-th condition, if its k-th epoch spans time points t_m to
t_n-1, then [i, k, t_m:t_n] are 1 in the epoch file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stimfunction</strong> (<em>list</em><em> of </em><em>timepoint by condition arrays</em>) – The stimulus function describing the time course of events. Each
list entry is from a different participant, each row is a different
timepoint (with the given temporal precision), each column is a
different condition. export_epoch_file is looking for differences in
the value of stimfunction to identify the start and end of an
epoch. If epochs in stimfunction are coded with the same weight and
there is no time between blocks then export_epoch_file won’t be able to
label them as different epochs</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – The name of the epoch file to be output</p></li>
<li><p><strong>tr_duration</strong> (<em>float</em>) – How long is each TR in seconds</p></li>
<li><p><strong>temporal_resolution</strong> (<em>float</em>) – How many elements per second are you modeling with the
stimfunction?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.generate_1d_gaussian_rfs">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">generate_1d_gaussian_rfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_voxels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_tuning</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rf_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.generate_1d_gaussian_rfs" title="Permalink to this definition"></a></dt>
<dd><p>Creates a numpy matrix of Gaussian-shaped voxel receptive fields (RFs)
along one dimension. Can specify whether they are evenly tiled or randomly
tuned along the axis. RF range will be between 0 and 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_voxels</strong> (<em>int</em>) – Number of voxel RFs to create.</p></li>
<li><p><strong>feature_resolution</strong> (<em>int</em>) – Number of points along the feature axis.</p></li>
<li><p><strong>feature_range</strong> (<em>tuple</em><em> (</em><em>numeric</em><em>)</em>) – A tuple indicating the start and end values of the feature range. e.g.
(0, 359) for motion directions.</p></li>
<li><p><strong>rf_size</strong> (<em>numeric</em>) – Width of the Gaussian receptive field. Should be given in units of the
feature dimension. e.g., 15 degrees wide in motion direction space.</p></li>
<li><p><strong>random_tuning</strong> (<em>boolean</em><em> [</em><em>default True</em><em>]</em>) – Indicates whether or not the voxels are randomly tuned along the 1D
feature axis or whether tuning is evenly spaced.</p></li>
<li><p><strong>rf_noise</strong> (<em>float</em><em> [</em><em>default 0.</em><em>]</em>) – Amount of uniform noise to add to the Gaussian RF. This will cause the
generated responses to be distorted by the same uniform noise for a
given voxel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>voxel_rfs</strong> (<em>2d numpy array (float)</em>) – The receptive fields in feature space. Dimensions are n_voxels by
feature_resolution.</p></li>
<li><p><strong>voxel_tuning</strong> (<em>1d numpy array (float)</em>) – The centers of the voxel RFs, in feature space.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.generate_1d_rf_responses">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">generate_1d_rf_responses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rfs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_resolution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_noise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.generate_1d_rf_responses" title="Permalink to this definition"></a></dt>
<dd><p>Generates trial-wise data for a given set of receptive fields (RFs) and
a 1d array of features presented across trials.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voxel_rfs</strong> (<em>2d numpy array</em><em> (</em><em>float</em><em>)</em>) – The receptive fields in feature space. Dimensions must be n_voxels
by feature_resolution.</p></li>
<li><p><strong>trial_list</strong> (<em>1d numpy array</em><em> (</em><em>numeric</em><em>)</em>) – The feature value of the stimulus presented on individual trials.
Array size be n_trials.</p></li>
<li><p><strong>feature_resolution</strong> (<em>int</em>) – Number of points along the feature axis.</p></li>
<li><p><strong>feature_range</strong> (<em>tuple</em><em> (</em><em>numeric</em><em>)</em>) – A tuple indicating the start and end values of the feature range. e.g.
(0, 359) for motion directions.</p></li>
<li><p><strong>trial_noise</strong> (<em>float</em><em> [</em><em>default 0.25</em><em>]</em>) – Amount of uniform noise to inject into the synthetic data. This is
generated independently for every trial and voxel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>trial_data</strong> – The synthetic data for each voxel and trial. Dimensions are n_voxels by
n_trials.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2d numpy array (float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.generate_noise">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">generate_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stimfunction_tr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tr_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noise_dict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_proportion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_thresh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.generate_noise" title="Permalink to this definition"></a></dt>
<dd><p>Generate the noise to be added to the signal.
Default noise parameters will create a noise volume with a standard
deviation of 0.1 (where the signal defaults to a value of 1). This has
built into estimates of how different types of noise mix. All noise
values can be set by the user or estimated with calc_noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimensions</strong> (<em>nd array</em>) – What is the shape of the volume to be generated</p></li>
<li><p><strong>stimfunction_tr</strong> (<em>Iterable</em><em>, </em><em>list</em>) – When do the stimuli events occur. Each element is a TR</p></li>
<li><p><strong>tr_duration</strong> (<em>float</em>) – What is the duration, in seconds, of each TR?</p></li>
<li><p><strong>template</strong> (<em>3d array</em><em>, </em><em>float</em>) – A continuous (0 -&gt; 1) volume describing the likelihood a voxel is in
the brain. This can be used to contrast the brain and non brain.</p></li>
<li><p><strong>mask</strong> (<em>3d array</em><em>, </em><em>binary</em>) – The mask of the brain volume, distinguishing brain from non-brain</p></li>
<li><p><strong>noise_dict</strong> (<em>dict</em>) – <p>A dictionary specifying the types of noise in this experiment. The
noise types interact in important ways. First, autoregressive,
physiological and task-based noise types are mixed together in
_generate_temporal_noise. The parameter values for ‘auto_reg_sigma’,
‘physiological_sigma’ and ‘task_sigma’ describe the proportion of
mixing of these elements, respectively. However critically, ‘SFNR’ is
the parameter that controls how much noise these components contribute
to the brain. ‘auto_reg_rho’ and ‘ma_rho’ set parameters for the
autoregressive noise being simulated. Second, drift noise is added to
this, according to the size of ‘drift_sigma’. Thirdly, system noise is
added based on the ‘SNR’ parameter. Finally, ‘fwhm’ is used to estimate
the smoothness of the noise being inserted. If ‘matched’ is set to
true, then it will fit the parameters to match the participant as best
as possible.</p>
<p>Variables defined as follows:</p>
<p>snr [float]: Ratio of MR signal to the spatial noise
sfnr [float]: Ratio of the MR signal to the temporal noise. This is the
total variability that the following sigmas ‘sum’ to:</p>
<p>task_sigma [float]: Size of the variance of task specific noise
auto_reg_sigma [float]: Size of the variance of autoregressive
noise. This is an ARMA process where the AR and MA components can be
separately specified
physiological_sigma [float]: Size of the variance of physiological
noise</p>
<p>drift_sigma [float]: Size of the variance of drift noise</p>
<p>auto_reg_rho [list]: The coefficients of the autoregressive
components you are modeling
ma_rho [list]:The coefficients of the moving average components you
are modeling
max_activity [float]: The max value of the averaged brain in order
to reference the template
voxel_size [list]: The mm size of the voxels
fwhm [float]: The gaussian smoothing kernel size (mm)
matched [bool]: Specify whether you are fitting the noise parameters</p>
<p>The volumes of brain noise that are generated have smoothness
specified by ‘fwhm’</p>
</p></li>
<li><p><strong>temporal_proportion</strong> – What is the proportion of the temporal variance (as specified by the
SFNR noise parameter) that is accounted for by the system noise. If
this number is high then all of the temporal variability is due to
system noise, if it is low then all of the temporal variability is
due to brain variability.</p></li>
<li><p><strong>float</strong> – What is the proportion of the temporal variance (as specified by the
SFNR noise parameter) that is accounted for by the system noise. If
this number is high then all of the temporal variability is due to
system noise, if it is low then all of the temporal variability is
due to brain variability.</p></li>
<li><p><strong>iterations</strong> (<em>list</em><em>, </em><em>int</em>) – The first element is how many steps of fitting the SFNR and SNR values
will be performed. Usually converges after &lt; 5. The second element
is the number of iterations for the AR fitting. This is much more
time consuming (has to make a new timecourse on each iteration) so
be careful about setting this appropriately.</p></li>
<li><p><strong>fit_thresh</strong> (<em>float</em>) – What proportion of the target parameter value is sufficient error to
warrant finishing fit search.</p></li>
<li><p><strong>fit_delta</strong> (<em>float</em>) – How much are the parameters attenuated during the fitting process,
in terms of the proportion of difference between the target
parameter and the actual parameter</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>noise</strong> – Generates the noise volume for these parameters</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>multidimensional array, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.generate_signal">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">generate_signal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dimensions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_magnitude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signal_constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.generate_signal" title="Permalink to this definition"></a></dt>
<dd><p>Generate volume containing signal</p>
<p>Generate signal, of a specific shape in specific regions, for a single
volume. This will then be convolved with the HRF across time</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dimensions</strong> (<em>1d array</em><em>, </em><em>ndarray</em>) – What are the dimensions of the volume you wish to create</p></li>
<li><p><strong>feature_coordinates</strong> (<em>multidimensional array</em>) – What are the feature_coordinates of the signal being created.
Be aware of clipping: features far from the centre of the
brain will be clipped. If you wish to have multiple features
then list these as a features x 3 array. To create a feature of
a unique shape then supply all the individual
feature_coordinates of the shape and set the feature_size to 1.</p></li>
<li><p><strong>feature_size</strong> (<em>list</em><em>, </em><em>int</em>) – How big is the signal. If feature_coordinates=1 then only one value is
accepted, if feature_coordinates&gt;1 then either one value must be
supplied or m values</p></li>
<li><p><strong>feature_type</strong> (<em>list</em><em>, </em><em>string</em>) – What feature_type of signal is being inserted? Options are cube,
loop, cavity, sphere. If feature_coordinates = 1 then
only one value is accepted, if feature_coordinates &gt; 1 then either
one value must be supplied or m values</p></li>
<li><p><strong>signal_magnitude</strong> (<em>list</em><em>, </em><em>float</em>) – What is the (average) magnitude of the signal being generated? A
value of 1 means that the signal is one standard deviation from the
noise</p></li>
<li><p><strong>signal_constant</strong> (<em>list</em><em>, </em><em>bool</em>) – Is the signal constant across the feature (for univariate activity)
or is it a random pattern of a given magnitude across the feature (for
multivariate activity)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>volume_signal</strong> – Creates a single volume containing the signal</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>3 dimensional array, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.generate_stimfunction">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">generate_stimfunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">onsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">event_durations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timing_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temporal_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.generate_stimfunction" title="Permalink to this definition"></a></dt>
<dd><p>Return the function for the timecourse events</p>
<p>When do stimuli onset, how long for and to what extent should you
resolve the fMRI time course. There are two ways to create this, either
by supplying onset, duration and weight information or by supplying a
timing file (in the three column format used by FSL).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>onsets</strong> (<em>list</em><em>, </em><em>int</em>) – What are the timestamps (in s) for when an event you want to
generate onsets?</p></li>
<li><p><strong>event_durations</strong> (<em>list</em><em>, </em><em>int</em>) – What are the durations (in s) of the events you want to
generate? If there is only one value then this will be assigned
to all onsets</p></li>
<li><p><strong>total_time</strong> (<em>int</em>) – How long (in s) is the experiment in total.</p></li>
<li><p><strong>weights</strong> (<em>list</em><em>, </em><em>float</em>) – What is the weight for each event (how high is the box car)? If
there is only one value then this will be assigned to all onsets</p></li>
<li><p><strong>timing_file</strong> (<em>string</em>) – The filename (with path) to a three column timing file (FSL) to
make the events. Still requires total_time to work</p></li>
<li><p><strong>temporal_resolution</strong> (<em>float</em>) – How many elements per second are you modeling for the
timecourse. This is useful when you want to model the HRF at an
arbitrarily high resolution (and then downsample to your TR later).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>stim_function</strong> – The time course of stimulus evoked activation. This has a temporal
resolution of temporal resolution / 1.0 elements per second</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1 by timepoint array, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim.mask_brain">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim.</span></span><span class="sig-name descname"><span class="pre">mask_brain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_self</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim.mask_brain" title="Permalink to this definition"></a></dt>
<dd><p>Mask the simulated volume
This creates a mask specifying the approximate likelihood that a voxel is
part of the brain. All values are bounded to the range of 0 to 1. An
appropriate threshold to isolate brain voxels is &gt;0.2. Critically,
the data that should be used to create a template shouldn’t already be
masked/skull stripped. If it is then it will give in accurate estimates
of non-brain noise and corrupt estimations of SNR.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>volume</strong> (<em>multidimensional array</em>) – Either numpy array of a volume or a tuple describing the dimensions
of the mask to be created</p></li>
<li><p><strong>template_name</strong> (<em>str</em>) – What is the path to the template to be loaded? If empty then it
defaults to an MNI152 grey matter mask. This is ignored if mask_self
is True.</p></li>
<li><p><strong>mask_threshold</strong> (<em>float</em>) – What is the threshold (0 -&gt; 1) for including a voxel in the mask? If
None then the program will try and identify the last wide peak in a
histogram of the template (assumed to be the brain voxels) and takes
the minima before that peak as the threshold. Won’t work when the
data is not bimodal.</p></li>
<li><p><strong>mask_self</strong> (<em>bool</em><em> or </em><em>None</em>) – If set to true then it makes a mask from the volume supplied (by
averaging across time points and changing the range). If it is set
to false then it will use the template_name as an input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mask</strong> (<em>3 dimensional array, binary</em>) – The masked brain, thresholded to distinguish brain and non-brain</p></li>
<li><p><strong>template</strong> (<em>3 dimensional array, float</em>) – A continuous (0 -&gt; 1) volume describing the likelihood a voxel is in
the brain. This can be used to contrast the brain and non brain.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-brainiak.utils.fmrisim_real_time_generator">
<span id="brainiak-utils-fmrisim-real-time-generator-module"></span><h2>brainiak.utils.fmrisim_real_time_generator module<a class="headerlink" href="#module-brainiak.utils.fmrisim_real_time_generator" title="Permalink to this heading"></a></h2>
<p>This code can be run as a function in python or from the command line:
python fmrisim_real-time_generator –outputDir data</p>
<p>The input arguments are:
Required:
outputDir - Specify output data dir where the data should be saved</p>
<p>Optional (can be modified by flags from the command line):
data_dict contains:
numTRs - Specify the number of time points
multivariate_patterns - Is the difference between conditions univariate (0)
or multivariate (1)
different_ROIs - Are there different ROIs for each condition (1) or is
it in the same ROI (0). If it is the same ROI and you are using univariate
differences, the second condition will have a smaller evoked response than
the other.
event_duration - How long, in seconds, is each event
scale_percentage - What is the percent signal change
trDuration - How many seconds per volume
save_dicom - Do you want to save data as a dicom (1) or numpy (0)
save_realtime - Do you want to save the data in real time (1) or as fast as
possible (0)?
isi - What is the time between each event (in seconds)
burn_in - How long before the first event (in seconds)</p>
<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.fmrisim_real_time_generator.generate_data">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.fmrisim_real_time_generator.</span></span><span class="sig-name descname"><span class="pre">generate_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outputDir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_settings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.fmrisim_real_time_generator.generate_data" title="Permalink to this definition"></a></dt>
<dd><p>Generate simulated fMRI data
Use a few parameters that might be relevant for real time analysis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outputDir</strong> (<em>str</em>) – Specify output data dir where the data should be saved</p></li>
<li><p><strong>user_settings</strong> (<em>dict</em>) – A dictionary to specify the parameters used for making data,
specifying the following keys
numTRs - int - Specify the number of time points
multivariate_patterns - bool - Is the difference between conditions
univariate (0) or multivariate (1)
different_ROIs - bool - Are there different ROIs for each condition (
1) or is it in the same ROI (0). If it is the same ROI and you are
using univariate differences, the second condition will have a
smaller evoked response than the other.
event_duration - int - How long, in seconds, is each event
scale_percentage - float - What is the percent signal change
trDuration - float - How many seconds per volume
save_dicom - bool - Save to data as a dicom (1) or numpy (0)
save_realtime - bool - Do you want to save the data in real time (1)
or as fast as possible (0)?
isi - float - What is the time between each event (in seconds)
burn_in - int - How long before the first event (in seconds)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-brainiak.utils.kronecker_solvers">
<span id="brainiak-utils-kronecker-solvers-module"></span><h2>brainiak.utils.kronecker_solvers module<a class="headerlink" href="#module-brainiak.utils.kronecker_solvers" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.kronecker_solvers.tf_kron_mult">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.kronecker_solvers.</span></span><span class="sig-name descname"><span class="pre">tf_kron_mult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.kronecker_solvers.tf_kron_mult" title="Permalink to this definition"></a></dt>
<dd><p>Tensorflow multiply with kronecker product matrix
Returns kron(L[0], L[1] …) * x</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>list</em><em> of </em><em>2-D tensors</em>) – Each element of the list must be a tensorflow tensor and
must be a square matrix of dimension n_i x n_i</p></li>
<li><p><strong>x</strong> (<em>1-D</em><em> or </em><em>2-D tensor</em>) – Dimension (n_0*n_1*..n_(m-1)) x p</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>y</strong> – Dimension (n_0*n_1*..n_(m-1)) x p</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1-D or 2-D tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.kronecker_solvers.tf_masked_triangular_solve">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.kronecker_solvers.</span></span><span class="sig-name descname"><span class="pre">tf_masked_triangular_solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.kronecker_solvers.tf_masked_triangular_solve" title="Permalink to this definition"></a></dt>
<dd><p>Tensorflow function to solve L x = y
where L is a lower triangular matrix with a mask</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>L</strong> (<em>2-D tensor</em>) – Must be a tensorflow tensor and
must be a triangular matrix of dimension n x n</p></li>
<li><p><strong>y</strong> (<em>1-D</em><em> or </em><em>2-D tensor</em>) – Dimension n x p</p></li>
<li><p><strong>mask</strong> (<em>1-D tensor</em>) – Dimension n x 1, should be 1 if element is valid, 0 if invalid</p></li>
<li><p><strong>lower</strong> (<em>boolean</em><em> (</em><em>default : True</em><em>)</em>) – True if L is lower triangular, False if upper triangular</p></li>
<li><p><strong>adjoint</strong> (<em>boolean</em><em> (</em><em>default : False</em><em>)</em>) – True if solving for L^T x = y, False if solving for Lx = y</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>x</strong> – Dimension n x p, values at rows for which mask == 0 are set to zero</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1-D or 2-D tensor</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-brainiak.utils.utils">
<span id="brainiak-utils-utils-module"></span><h2>brainiak.utils.utils module<a class="headerlink" href="#module-brainiak.utils.utils" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">ReadDesign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_orth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_pols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="simple">
<dt>A class which has the ability of reading in design matrix in .1D file,</dt><dd><p>generated by AFNI’s 3dDeconvolve.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>string</em><em>, </em><em>the address</em><em> of </em><em>the file to read.</em>) – </p></li>
<li><p><strong>include_orth</strong> (<em>Boollean</em><em>, </em><em>whether to include &quot;orthogonal&quot; regressors in</em>) – the nuisance regressors which are usually head motion parameters.
All the columns of design matrix are still going to be read in,
but the attribute cols_used will reflect whether these orthogonal
regressors are to be included for furhter analysis.
Note that these are not entered into design_task attribute which
include only regressors related to task conditions.</p></li>
<li><p><strong>include_pols</strong> (<em>Boollean</em><em>, </em><em>whether to include polynomial regressors in</em>) – the nuisance regressors which are used to capture slow drift of
signals.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.design">
<span class="sig-name descname"><span class="pre">design</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.design" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>2d array. The design matrix read in from the csv file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.design_task">
<span class="sig-name descname"><span class="pre">design_task</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.design_task" title="Permalink to this definition"></a></dt>
<dd><p>task conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>2d array. The part of design matrix corresponding to</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.n_col">
<span class="sig-name descname"><span class="pre">n_col</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.n_col" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>number of total columns in the design matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.column_types">
<span class="sig-name descname"><span class="pre">column_types</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.column_types" title="Permalink to this definition"></a></dt>
<dd><p>0 for orthogonal regressors (usually head motion parameters),
-1 for polynomial basis (capturing slow drift of signals),
values &gt; 0 for stimulus conditions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>1d array. the types of each column in the design matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.n_basis">
<span class="sig-name descname"><span class="pre">n_basis</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.n_basis" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>scalar. The number of polynomial bases in the designn matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.n_stim">
<span class="sig-name descname"><span class="pre">n_stim</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.n_stim" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>scalar. The number of stimulus conditions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.n_orth">
<span class="sig-name descname"><span class="pre">n_orth</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.n_orth" title="Permalink to this definition"></a></dt>
<dd><p>motions)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>scalar. The number of orthogoanal regressors (usually head</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.StimLabels">
<span class="sig-name descname"><span class="pre">StimLabels</span></span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.StimLabels" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list. The names of each column in the design matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.utils.utils.ReadDesign.read_afni">
<span class="sig-name descname"><span class="pre">read_afni</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.ReadDesign.read_afni" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.array_correlation">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">array_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.array_correlation" title="Permalink to this definition"></a></dt>
<dd><p>Column- or row-wise Pearson correlation between two arrays</p>
<p>Computes sample Pearson correlation between two 1D or 2D arrays (e.g.,
two n_TRs by n_voxels arrays). For 2D arrays, computes correlation
between each corresponding column (axis=0) or row (axis=1) where axis
indexes observations. If axis=0 (default), each column is considered to
be a variable and each row is an observation; if axis=1, each row is a
variable and each column is an observation (equivalent to transposing
the input arrays). Input arrays must be the same shape with corresponding
variables and observations. This is intended to be an efficient method
for computing correlations between two corresponding arrays with many
variables (e.g., many voxels).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>1D</em><em> or </em><em>2D ndarray</em>) – Array of observations for one or more variables</p></li>
<li><p><strong>y</strong> (<em>1D</em><em> or </em><em>2D ndarray</em>) – Array of observations for one or more variables (same shape as x)</p></li>
<li><p><strong>axis</strong> (<em>int</em><em> (</em><em>0</em><em> or </em><em>1</em><em>)</em><em>, </em><em>default: 0</em>) – Correlation between columns (axis=0) or rows (axis=1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>r</strong> – Pearson correlation values for input variables</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float or 1D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.center_mass_exp">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">center_mass_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.center_mass_exp" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Calculate the center of mass of negative exponential distribution</dt><dd><p>p(x) = exp(-x / scale) / scale
in the interval of (interval_left, interval_right).
scale is the same scale parameter as scipy.stats.expon.pdf</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>interval</strong> (<em>size 2 tuple</em><em>, </em><em>float</em>) – interval must be in the form of (interval_left, interval_right),
where interval_left/interval_right is the starting/end point of the
interval in which the center of mass is calculated for exponential
distribution.
Note that interval_left must be non-negative, since exponential is
not supported in the negative domain, and interval_right must be
bigger than interval_left (thus positive) to form a well-defined
interval.</p></li>
<li><p><strong>scale</strong> (<em>float</em><em>, </em><em>positive</em>) – The scale parameter of the exponential distribution. See above.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>m</strong> – The center of mass in the interval of (interval_left,
interval_right) for exponential distribution.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.circ_dist">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">circ_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.circ_dist" title="Permalink to this definition"></a></dt>
<dd><p>Computes the pairwise circular distance between two arrays of
points (in radians).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy vector</em><em> of </em><em>positions on a circle</em><em>, </em><em>in radians.</em>) – </p></li>
<li><p><strong>y</strong> (<em>numpy vector</em><em> of </em><em>positions on a circle</em><em>, </em><em>in radians.</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>r</strong></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy vector of distances between inputs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.concatenate_not_none">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">concatenate_not_none</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.concatenate_not_none" title="Permalink to this definition"></a></dt>
<dd><p>Construct a numpy array by stacking not-None arrays in a list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>list</em><em> of </em><em>arrays</em>) – The list of arrays to be concatenated. Arrays have same shape in all
but one dimension or are None, in which case they are ignored.</p></li>
<li><p><strong>axis</strong> (<em>int</em><em>, </em><em>default = 0</em>) – Axis for the concatenation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data_stacked</strong> – The resulting concatenated array.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.cov2corr">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">cov2corr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.cov2corr" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Calculate the correlation matrix based on a</dt><dd><p>covariance matrix</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cov</strong> (<em>2D array</em>) – </p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>corr</strong> – correlation converted from the covarince matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.from_sym_2_tri">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">from_sym_2_tri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.from_sym_2_tri" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>convert a 2D symmetric matrix to an upper</dt><dd><p>triangular matrix in 1D format</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>symm</strong> (<em>2D array</em>) – Symmetric matrix</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tri</strong> – Contains elements of upper triangular matrix</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>1D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.from_tri_2_sym">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">from_tri_2_sym</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tri</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.from_tri_2_sym" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>convert a upper triangular matrix in 1D format</dt><dd><p>to 2D symmetric matrix</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tri</strong> (<em>1D array</em>) – Contains elements of upper triangular matrix</p></li>
<li><p><strong>dim</strong> (<em>int</em>) – The dimension of target matrix.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>symm</strong> – Symmetric matrix in shape=[dim, dim]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.gen_design">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">gen_design</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stimtime_files</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_duration</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">TR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">style</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'FSL'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_res</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hrf_para</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'response_delay':</span> <span class="pre">6,</span> <span class="pre">'response_dispersion':</span> <span class="pre">0.9,</span> <span class="pre">'undershoot_delay':</span> <span class="pre">12,</span> <span class="pre">'undershoot_dispersion':</span> <span class="pre">0.9,</span> <span class="pre">'undershoot_scale':</span> <span class="pre">0.035}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.gen_design" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Generate design matrix based on a list of names of stimulus</dt><dd><p>timing files. The function will read each file, and generate
a numpy array of size [time_points * condition], where
time_points equals duration / TR, and condition is the size of
stimtime_filenames. Each column is the hypothetical fMRI response
based on the stimulus timing in the corresponding file
of stimtime_files.
This function uses generate_stimfunction and double_gamma_hrf
of brainiak.utils.fmrisim.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>stimtime_files</strong> (<em>a string</em><em> or </em><em>a list</em><em> of </em><em>string.</em>) – Each string is the name of the file storing
the stimulus timing information of one task condition.
The contents in the files will be interpretated
based on the style parameter.
Details are explained under the style parameter.</p></li>
<li><p><strong>scan_duration</strong> (<em>float</em><em> or </em><em>a list</em><em> (or </em><em>a 1D numpy array</em><em>) of </em><em>numbers.</em>) – Total duration of each fMRI scan, in unit of seconds.
If there are multiple runs, the duration should be
a list (or 1-d numpy array) of numbers.
If it is a list, then each number in the list
represents the duration of the corresponding scan
in the stimtime_files.
If only a number is provided, it is assumed that
there is only one fMRI scan lasting for scan_duration.</p></li>
<li><p><strong>TR</strong> (<em>float.</em>) – The sampling period of fMRI, in unit of seconds.</p></li>
<li><p><strong>style</strong> (<em>string</em><em>, </em><em>default: 'FSL'</em>) – <p>Acceptable inputs: ‘FSL’, ‘AFNI’
The formating style of the stimtime_files.
‘FSL’ style has one line for each event of the same condition.
Each line contains three numbers. The first number is the onset
of the event relative to the onset of the first scan,
in units of seconds.
(Multiple scans should be treated as a concatenated long scan
for the purpose of calculating onsets.
However, the design matrix from one scan won’t leak into the next).
The second number is the duration of the event,
in unit of seconds.
The third number is the amplitude modulation (or weight)
of the response.
It is acceptable to not provide the weight,
or not provide both duration and weight.
In such cases, these parameters will default to 1.0.
This code will accept timing files with only 1 or 2 columns for
convenience but please note that the FSL package does not allow this</p>
<p>’AFNI’ style has one line for each scan (run).
Each line has a few triplets in the format of
stim_onsets*weight:duration
(or simpler, see below), separated by spaces.
For example, 3.2*2.0:1.5 means that one event starts at 3.2s,
modulated by weight of 2.0 and lasts for 1.5s.
If some run does not include a single event
of a condition (stimulus type), then you can put *,
or a negative number, or a very large number in that line.
Either duration or weight can be neglected. In such
cases, they will default to 1.0.
For example, 3.0, 3.0*1.0, 3.0:1.0 and 3.0*1.0:1.0 all
means an event starting at 3.0s, lasting for 1.0s, with
amplitude modulation of 1.0.</p>
</p></li>
<li><p><strong>temp_res</strong> (<em>float</em><em>, </em><em>default: 0.01</em>) – Temporal resolution of fMRI, in second.</p></li>
<li><p><strong>hrf_para</strong> (<em>dictionary</em>) – The parameters of the double-Gamma hemodynamic response function.
To set different parameters, supply a dictionary with
the same set of keys as the default, and replace the corresponding
values with the new values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>design</strong> – design matrix. Each time row represents one TR
(fMRI sampling time point) and each column represents
one experiment condition, in the order in stimtime_files</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2D numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.p_from_null">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">p_from_null</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">side</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'two-sided'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.p_from_null" title="Permalink to this definition"></a></dt>
<dd><p>Compute p-value from null distribution</p>
<p>Returns the p-value for an observed test statistic given a null
distribution. Performs either a ‘two-sided’ (i.e., two-tailed)
test (default) or a one-sided (i.e., one-tailed) test for either the
‘left’ or ‘right’ side. For an exact test (exact=True), does not adjust
for the observed test statistic; otherwise, adjusts for observed
test statistic (prevents p-values of zero). If a multidimensional
distribution is provided, use axis argument to specify which axis indexes
resampling iterations.</p>
<p>The implementation is based on the work in <a class="reference internal" href="#phipsonsmyth2010" id="id1"><span>[PhipsonSmyth2010]</span></a>.</p>
<dl class="citation">
<dt class="label" id="phipsonsmyth2010"><span class="brackets"><a class="fn-backref" href="#id1">PhipsonSmyth2010</a></span></dt>
<dd><p>“Permutation p-values should never be zero:
calculating exact p-values when permutations are randomly drawn.”,
B. Phipson, G. K., Smyth, 2010, Statistical Applications in Genetics
and Molecular Biology, 9, 1544-6115.
<a class="reference external" href="https://doi.org/10.2202/1544-6115.1585">https://doi.org/10.2202/1544-6115.1585</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>observed</strong> (<em>float</em>) – Observed test statistic</p></li>
<li><p><strong>distribution</strong> (<em>ndarray</em>) – Null distribution of test statistic</p></li>
<li><p><strong>side</strong> (<em>str</em><em>, </em><em>default: 'two-sided'</em>) – Perform one-sided (‘left’ or ‘right’) or ‘two-sided’ test</p></li>
<li><p><strong>axis</strong> (<em>None</em><em> or </em><em>int</em><em>, </em><em>default: None</em>) – Axis indicating resampling iterations in input distribution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>p</strong> – p-value for observed test statistic based on null distribution</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.phase_randomize">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">phase_randomize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voxelwise</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_state</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.phase_randomize" title="Permalink to this definition"></a></dt>
<dd><p>Randomize phase of time series across subjects</p>
<p>For each subject, apply Fourier transform to voxel time series
and then randomly shift the phase of each frequency before inverting
back into the time domain. This yields time series with the same power
spectrum (and thus the same autocorrelation) as the original time series
but will remove any meaningful temporal relationships among time series
across subjects. By default (voxelwise=False), the same phase shift is
applied across all voxels; however if voxelwise=True, different random
phase shifts are applied to each voxel. The typical input is a time by
voxels by subjects ndarray. The first dimension is assumed to be the
time dimension and will be phase randomized. If a 2-dimensional ndarray
is provided, the last dimension is assumed to be subjects, and different
phase randomizations will be applied to each subject.</p>
<p>The implementation is based on the work in <a class="reference internal" href="brainiak.html#lerner2011" id="id2"><span>[Lerner2011]</span></a> and
<a class="reference internal" href="brainiak.html#simony2016" id="id3"><span>[Simony2016]</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>ndarray</em><em> (</em><em>n_TRs x n_voxels x n_subjects</em><em>)</em>) – Data to be phase randomized (per subject)</p></li>
<li><p><strong>voxelwise</strong> (<em>bool</em><em>, </em><em>default: False</em>) – Apply same (False) or different (True) randomizations across voxels</p></li>
<li><p><strong>random_state</strong> (<em>RandomState</em><em> or </em><em>an int seed</em><em> (</em><em>0 by default</em><em>)</em>) – A random number generator instance to define the state of the
random permutations generator.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>shifted_data</strong> – Phase-randomized time series</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray (n_TRs x n_voxels x n_subjects)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.sumexp_stable">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">sumexp_stable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.sumexp_stable" title="Permalink to this definition"></a></dt>
<dd><p>Compute the sum of exponents for a list of samples</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>array</em><em>, </em><em>shape=</em><em>[</em><em>features</em><em>, </em><em>samples</em><em>]</em>) – A data array containing samples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>result_sum</strong> (<em>array, shape=[samples,]</em>) – The sum of exponents for each sample divided by the exponent
of the maximum feature value in the sample.</p></li>
<li><p><strong>max_value</strong> (<em>array, shape=[samples,]</em>) – The maximum feature value for each sample.</p></li>
<li><p><strong>result_exp</strong> (<em>array, shape=[features, samples]</em>) – The exponent of each element in each sample divided by the exponent
of the maximum feature value in the sample.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function is more stable than computing the sum(exp(v)).
It useful for computing the softmax_i(v)=exp(v_i)/sum(exp(v)) function.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.utils.utils.usable_cpu_count">
<span class="sig-prename descclassname"><span class="pre">brainiak.utils.utils.</span></span><span class="sig-name descname"><span class="pre">usable_cpu_count</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.utils.utils.usable_cpu_count" title="Permalink to this definition"></a></dt>
<dd><p>Get number of CPUs usable by the current process.</p>
<p>Takes into consideration cpusets restrictions.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="brainiak.searchlight.html" class="btn btn-neutral float-left" title="brainiak.searchlight package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="contributing.html" class="btn btn-neutral float-right" title="Contributing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Princeton Neuroscience Institute and Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>