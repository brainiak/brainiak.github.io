<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>brainiak.matnormal package &mdash; brainiak 0.12 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="brainiak.reconstruct package" href="brainiak.reconstruct.html" />
    <link rel="prev" title="brainiak.hyperparamopt package" href="brainiak.hyperparamopt.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            brainiak
          </a>
              <div class="version">
                0.12
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">brainiak</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="api.html">API</a></li>
          <li class="breadcrumb-item"><a href="brainiak.html">brainiak package</a></li>
      <li class="breadcrumb-item active">brainiak.matnormal package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/brainiak.matnormal.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="module-brainiak.matnormal">
<span id="brainiak-matnormal-package"></span><h1>brainiak.matnormal package<a class="headerlink" href="#module-brainiak.matnormal" title="Permalink to this heading"></a></h1>
<div class="section" id="some-properties-of-the-matrix-variate-normal-distribution">
<h2>Some properties of the matrix-variate normal distribution<a class="headerlink" href="#some-properties-of-the-matrix-variate-normal-distribution" title="Permalink to this heading"></a></h2>
<div class="math notranslate nohighlight">
\[\DeclareMathOperator{\Tr}{Tr}
\newcommand{\trp}{^{T}} % transpose
\newcommand{\trace}{\text{Trace}} % trace
\newcommand{\inv}{^{-1}}
\newcommand{\mb}{\mathbf{b}}
\newcommand{\M}{\mathbf{M}}
\newcommand{\C}{\mathbf{C}}
\newcommand{\G}{\mathbf{G}}
\newcommand{\A}{\mathbf{A}}
\newcommand{\R}{\mathbf{R}}
\renewcommand{\S}{\mathbf{S}}
\newcommand{\B}{\mathbf{B}}
\newcommand{\Q}{\mathbf{Q}}
\newcommand{\mH}{\mathbf{H}}
\newcommand{\U}{\mathbf{U}}
\newcommand{\mL}{\mathbf{L}}
\newcommand{\diag}{\mathrm{diag}}
\newcommand{\etr}{\mathrm{etr}}
\renewcommand{\H}{\mathbf{H}}
\newcommand{\vecop}{\mathrm{vec}}
\newcommand{\I}{\mathbf{I}}
\newcommand{\X}{\mathbf{X}}
\newcommand{\Y}{\mathbf{Y}}
\newcommand{\Z}{\mathbf{Z}}
\renewcommand{\L}{\mathbf{L}}\]</div>
<p>The matrix-variate normal distribution is a generalization to matrices of the
normal distribution. Another name for it is the multivariate normal
distribution with kronecker separable covariance.
The distributional intuition is as follows: if
<span class="math notranslate nohighlight">\(X \sim \mathcal{MN}(M,R,C)\)</span> then
<span class="math notranslate nohighlight">\(\mathrm{vec}(X)\sim\mathcal{N}(\mathrm{vec}(M), C \otimes R)\)</span>,
where <span class="math notranslate nohighlight">\(\mathrm{vec}(\cdot)\)</span> is the vectorization operator and
<span class="math notranslate nohighlight">\(\otimes\)</span> is the Kronecker product. If we think of X as a matrix of TRs
by voxels in the fMRI setting, then this model assumes that each voxel has the
same TR-by-TR covariance structure (represented by the matrix R),
and each volume has the same spatial covariance (represented by the matrix C).
This assumption allows us to model both covariances separately.
We can assume that the spatial covariance itself is kronecker-structured,
which implies that the spatial covariance of voxels is the same in the X,
Y and Z dimensions.</p>
<p>The log-likelihood for the matrix-normal density is:</p>
<div class="math notranslate nohighlight">
\[\log p(X\mid \M,\R, \C) = -2\log mn - m \log|\C| -  n \log|\R| -
\Tr\left[\C\inv(\X-\M)\trp\R\inv(\X-\M)\right]\]</div>
<p>Here <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(M\)</span> are both <span class="math notranslate nohighlight">\(m\times n\)</span> matrices, <span class="math notranslate nohighlight">\(\R\)</span>
is <span class="math notranslate nohighlight">\(m\times m\)</span> and <span class="math notranslate nohighlight">\(\C\)</span> is <span class="math notranslate nohighlight">\(n\times n\)</span>.</p>
<p>The <a class="reference internal" href="#module-brainiak.matnormal" title="brainiak.matnormal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">brainiak.matnormal</span></code></a> package provides structure to infer models that
can be stated in the matrix-normal notation that are useful for fMRI analysis.
It provides a few interfaces. <code class="xref py py-obj docutils literal notranslate"><span class="pre">MatnormModelBase</span></code> is intended as a
base class for matrix-variate models. It provides a wrapper for the tensorflow
optimizer that provides convergence checks based on thresholds on the function
value and gradient, and simple verbose outputs. It also provides an interface
for noise covariances (<code class="xref py py-obj docutils literal notranslate"><span class="pre">CovBase</span></code>). Any class that follows the interface
can be used as a noise covariance in any of the matrix normal models. The
package includes a variety of noise covariances to work with.</p>
</div>
<div class="section" id="matrix-normal-marginals">
<h2>Matrix normal marginals<a class="headerlink" href="#matrix-normal-marginals" title="Permalink to this heading"></a></h2>
<p>Here we extend the multivariate gaussian marginalization identity to matrix
normals. This is used in a number of the models in the package. Below, we
use lowercase subscripts for sizes to make dimensionalities easier to track.
Uppercase subscripts for covariances help keep track where they come from.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{X}_{ij} &amp;\sim \mathcal{MN}(\mathbf{A}_{ij},
\Sigma_{\mathbf{X}i},\Sigma_{\mathbf{X}j})\\
\mathbf{Y}_{jk} &amp;\sim \mathcal{MN}(\mathbf{B}_{jk},
 \Sigma_{\mathbf{Y}j},\Sigma_{\mathbf{Y}k})\\
\mathbf{Z}_{ik}\mid\mathbf{X}_{ij},\mathbf{Y}_{jk} &amp;\sim
 \mathcal{MN}(\mathbf{X}_{ij}\mathbf{Y}_{jk} + \mathbf{C}_{ik},
  \Sigma_{\mathbf{Z}_i}, \Sigma_{\mathbf{Z}_k})\\\end{split}\]</div>
<p>We vectorize, and convert to a form we recognize as
<span class="math notranslate nohighlight">\(y \sim \mathcal{N}(Mx+b, \Sigma)\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij},\mathbf{Y}_{jk} &amp;\sim
 \mathcal{N}(\vecop(\X_{ij}\mathbf{Y}_{jk}+\mathbf{C}_{ik}),
 \Sigma_{\mathbf{Z}_k}\otimes\Sigma_{\mathbf{Z}_i})\\
\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij},\mathbf{Y}_{jk}
&amp;\sim \mathcal{N}((\I_k\otimes\X_{ij})\vecop(\mathbf{Y}_{jk})
 + \vecop(\mathbf{C}_{ik}),
 \Sigma_{\mathbf{Z}_k}\otimes\Sigma_{\mathbf{Z}_i})\end{split}\]</div>
<p>Now we can use our standard gaussian marginalization identity:</p>
<div class="math notranslate nohighlight">
\[\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij} \sim
\mathcal{N}((\I_k\otimes\X_{ij})\vecop(\mathbf{B}_{jk}) +
 \vecop(\mathbf{C}_{ik}),
 \Sigma_{\mathbf{Z}_k}\otimes\Sigma_{\mathbf{Z}_i} +
 (\I_k\otimes\X_{ij})(\Sigma_{\mathbf{Y}_k}\otimes
 \Sigma_{\mathbf{Y}_j})(\I_k\otimes\X_{ij})\trp )\]</div>
<p>Collect terms using the mixed-product property of kronecker products:</p>
<div class="math notranslate nohighlight">
\[\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij} \sim
 \mathcal{N}(\vecop(\X_{ij}\mathbf{B}_{jk}) +
  \vecop(\mathbf{C}_{ik}), \Sigma_{\mathbf{Z}_k}\otimes
  \Sigma_{\mathbf{Z}_i} + \Sigma_{\mathbf{Y}_k}\otimes
   \X_{ij}\Sigma_{\mathbf{Y}_j}\X_{ij}\trp)\]</div>
<p>Now, we can see that the marginal density is a matrix-variate normal only if
<span class="math notranslate nohighlight">\(\Sigma_{\mathbf{Z}_k}= \Sigma_{\mathbf{Y}_k}\)</span> – that is, the
variable we’re marginalizing over has the same covariance in the dimension
we’re <em>not</em> marginalizing over as the marginal density. Otherwise the densit
is well-defined but the covariance retains its kronecker structure. So we let
<span class="math notranslate nohighlight">\(\Sigma_k:=\Sigma_{\mathbf{Z}_k}= \Sigma_{\mathbf{Y}_k}\)</span>, factor,
and transform it back into a matrix normal:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij} &amp;\sim
 \mathcal{N}(\vecop(\X\mathbf{B}_{jk}) + \vecop(\mathbf{C}_{ik}),
  \Sigma_{k}\otimes\Sigma_{\mathbf{Z}_i} + \Sigma_{_k}\otimes
  \X\Sigma_{\mathbf{Y}_j}\X\trp)\\
\vecop(\mathbf{Z}_{ik})\mid\mathbf{X}_{ij} &amp;\sim
 \mathcal{N}(\vecop(\X\mathbf{B}_{jk}) + \vecop(\mathbf{C}_{ik}),
  \Sigma_{k}\otimes(\Sigma_{\mathbf{Z}_i}
  +\X\Sigma_{\mathbf{Y}_j}\X\trp))\\
\mathbf{Z}_{ik}\mid\mathbf{X}_{ij} &amp;\sim
 \mathcal{MN}(\X\mathbf{B}_{jk} + \mathbf{C}_{ik},
  \Sigma_{\mathbf{Z}_i} +\X\Sigma_{\mathbf{Y}_j}\X\trp,\Sigma_{k})\end{split}\]</div>
<p>We can do it in the other direction as well, because if
<span class="math notranslate nohighlight">\(\X \sim \mathcal{MN}(M, U, V)\)</span> then <span class="math notranslate nohighlight">\(\X\trp \sim
\mathcal{MN}(M\trp, V, U)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Z\trp}_{ik}\mid\mathbf{X}_{ij},\mathbf{Y}_{jk} &amp;\sim
\mathcal{MN}(\mathbf{Y}_{jk}\trp\mathbf{X}_{ij}\trp +
\mathbf{C}\trp_{ik}, \Sigma_{\mathbf{Z}_k},\Sigma_{\mathbf{Z}_i})\\
\mbox{let } \Sigma_i :=
 \Sigma_{\mathbf{Z}_i}=\Sigma_{\mathbf{X}_i} \\
\cdots\\
\mathbf{Z\trp}_{ik}\mid\mathbf{Y}_{jk} &amp;\sim
 \mathcal{MN}(\mathbf{A}_{jk}\trp\mathbf{X}_{ij}\trp +
  \mathbf{C}\trp_{ik}, \Sigma_{\mathbf{Z}_k} +
   \Y\trp\Sigma_{\mathbf{Y}_j}\Y,\Sigma_{\mathbf{Z}_i})\\
\mathbf{Z}_{ik}\mid\mathbf{Y}_{jk} &amp;\sim
 \mathcal{MN}(\mathbf{X}_{ij}\mathbf{A}_{jk}+
  \mathbf{C}_{ik},\Sigma_{\mathbf{Z}_i},\Sigma_{\mathbf{Z}_k} +
   \Y\trp\Sigma_{\mathbf{Y}_j}\Y)\end{split}\]</div>
<p>These marginal likelihoods are implemented relatively efficiently in
<code class="xref py py-obj docutils literal notranslate"><span class="pre">MatnormModelBase.matnorm_logp_marginal_row</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">MatnormModelBase.matnorm_logp_marginal_col</span></code>.</p>
</div>
<div class="section" id="partitioned-matrix-normal-conditionals">
<h2>Partitioned matrix normal conditionals<a class="headerlink" href="#partitioned-matrix-normal-conditionals" title="Permalink to this heading"></a></h2>
<p>Here we extend the multivariate gaussian conditional identity to matrix
normals. This is used for prediction in some models. Below, we
use lowercase subscripts for sizes to make dimensionalities easier to track.
Uppercase subscripts for covariances help keep track where they come from.</p>
<p>Next, we do the same for the partitioned gaussian identity. First two
vectorized matrix-normals that form our partition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{X}_{ij} &amp;\sim \mathcal{MN}(\mathbf{A}_{ij}, \Sigma_{i},
\Sigma_{j}) \rightarrow \vecop[\mathbf{X}_{ij}] \sim
\mathcal{N}(\vecop[\mathbf{A}_{ij}], \Sigma_{j}\otimes\Sigma_{i})\\
\mathbf{Y}_{ik} &amp;\sim \mathcal{MN}(\mathbf{B}_{ik}, \Sigma_{i},
\Sigma_{k}) \rightarrow \vecop[\mathbf{Y}_{ik}] \sim
\mathcal{N}(\vecop[\mathbf{B}_{ik}], \Sigma_{k}\otimes\Sigma_{i})\\
\begin{bmatrix}\vecop[\mathbf{X}_{ij}] \\ \vecop[\mathbf{Y}_{ik}]
\end{bmatrix}
&amp; \sim \mathcal{N}\left(\vecop\begin{bmatrix}\mathbf{A}_{ij}
\\ \mathbf{B}_{ik}
\end{bmatrix}
, \begin{bmatrix} \Sigma_{j}\otimes \Sigma_i  &amp;
 \Sigma_{jk} \otimes \Sigma_i  \\
\Sigma_{kj}\otimes \Sigma_i &amp; \Sigma_{k} \otimes
 \Sigma_i\end{bmatrix}\right)\end{split}\]</div>
<p>We apply the standard partitioned Gaussian identity and simplify using the
properties of the <span class="math notranslate nohighlight">\(\vecop\)</span> operator and the mixed product property
of kronecker products:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vecop[\X_{ij}] \mid \vecop[\Y_{ik}]\sim
\mathcal{N}(&amp;\vecop[\A_{ij}] + (\Sigma_{jk}\otimes\Sigma_i)
(\Sigma_k\inv\otimes\Sigma_i\inv)(\vecop[\Y_{ik}]-\vecop[\B_{ik}]),\\
&amp; \Sigma_j\otimes\Sigma_i -  (\Sigma_{jk}\otimes\Sigma_i)
(\Sigma_k\inv\otimes\Sigma_i\inv) (\Sigma_{kj}\otimes\Sigma_i))\\
=\mathcal{N}(&amp;\vecop[\A_{ij}] +
 (\Sigma_{jk}\Sigma_k\inv\otimes\Sigma_i\Sigma_i\inv)
 (\vecop[\Y_{ik}]-\vecop[\B_{ik}]), \\
 &amp; \Sigma_j\otimes\Sigma_i -
 (\Sigma_{jk}\Sigma_k\inv\Sigma_{kj}\otimes
 \Sigma_i\Sigma_i\inv \Sigma_i))\\
=\mathcal{N}(&amp;\vecop[\A_{ij}] + (\Sigma_{jk}\Sigma_k\inv\otimes\I)
(\vecop[\Y_{ik}]-\vecop[\B_{ik}]), \\
 &amp; \Sigma_j\otimes\Sigma_i -
 (\Sigma_{jk}\Sigma_k\inv\Sigma_{kj}\otimes\Sigma_i)\\
=\mathcal{N}(&amp;\vecop[\A_{ij}] +
\vecop[\Y_{ik}-\B_{ik}\Sigma_k\inv\Sigma_{kj}],
 (\Sigma_j-\Sigma_{jk}\Sigma_k\inv\Sigma_{kj})\otimes\Sigma_i)\end{split}\]</div>
<p>Next, we recognize that this multivariate gaussian is equivalent to the
following matrix variate gaussian:</p>
<div class="math notranslate nohighlight">
\[\X_{ij} \mid \Y_{ik}\sim \mathcal{MN}(\A_{ij} +
(\Y_{ik}-\B_{ik})\Sigma_k\inv\Sigma_{kj}, \Sigma_i,
\Sigma_j-\Sigma_{jk}\Sigma_k\inv\Sigma_{kj})\]</div>
<p>The conditional in the other direction can be written by working through the
same algebra:</p>
<div class="math notranslate nohighlight">
\[\Y_{ik} \mid \X_{ij}\sim \mathcal{MN}(\B_{ik} +(\X_{ij}-
\A_{ij})\Sigma_j\inv\Sigma_{jk}, \Sigma_i,
\Sigma_k-\Sigma_{kj}\Sigma_j\inv\Sigma_{jk})\]</div>
<p>Finally, vertical rather than horizontal concatenation (yielding a partitioned
row rather than column covariance) can be written by recognizing the behavior
of the matrix normal under transposition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\X\trp_{ji} \mid \Y\trp_{ki}\sim \mathcal{MN}(&amp;\A\trp_{ji} +
\Sigma_{jk}\Sigma_k\inv(\Y\trp_{ki}-\B\trp_{ki}),
 \Sigma_j-\Sigma_{jk}\Sigma_k\inv\Sigma_{kj}, \Sigma_i)\\
\Y\trp_{ki} \mid \X\trp_{ji}\sim \mathcal{MN}(&amp;\B\trp_{ki} +
\Sigma_{kj}\Sigma_j\inv(\X\trp_{ji}-\A\trp_{ji}),
 \Sigma_k-\Sigma_{kj}\Sigma_j\inv\Sigma_{jk}, \Sigma_i)\end{split}\]</div>
<p>These conditional likelihoods are implemented relatively efficiently
in <code class="xref py py-obj docutils literal notranslate"><span class="pre">MatnormModelBase.matnorm_logp_conditional_row</span></code> and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">MatnormModelBase.matnorm_logp_conditional_col</span></code>.</p>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</div>
<div class="section" id="module-brainiak.matnormal.covs">
<span id="brainiak-matnormal-covs-module"></span><h2>brainiak.matnormal.covs module<a class="headerlink" href="#module-brainiak.matnormal.covs" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovAR1">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovAR1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scan_onsets</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovAR1" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>AR(1) covariance parameterized by autoregressive parameter rho
and new noise sigma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – size of covariance matrix</p></li>
<li><p><strong>rho</strong> (<em>float</em><em> or </em><em>None</em>) – initial value of autoregressive parameter (if None, initialize
randomly)</p></li>
<li><p><strong>sigma</strong> (<em>float</em><em> or </em><em>None</em>) – initial value of new noise parameter (if None, initialize randomly)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovAR1.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovAR1.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to
fit this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovAR1.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovAR1.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log-determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovAR1.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovAR1.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovBase" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Base metaclass for residual covariances.
For more on abstract classes, see
<a class="reference external" href="https://docs.python.org/3/library/abc.html">https://docs.python.org/3/library/abc.html</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em>) – The size of the covariance matrix.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovBase.get_optimize_vars">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovBase.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to fit
this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovBase.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovBase.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovBase.solve">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovBase.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovDiagonal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovDiagonal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diag_var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovDiagonal" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Uncorrelated (diagonal) noise covariance</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – size of covariance matrix</p></li>
<li><p><strong>diag_var</strong> (<em>float</em><em> or </em><em>None</em>) – initial value of (diagonal) variance vector (if None, initialize
randomly)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovDiagonal.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovDiagonal.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to fit
this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovDiagonal.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovDiagonal.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovDiagonal.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovDiagonal.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>tf.Tensor</em>) – Tensor to multiply by inverse of this covariance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovDiagonalGammaPrior">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovDiagonalGammaPrior</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovDiagonalGammaPrior" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovDiagonal" title="brainiak.matnormal.covs.CovDiagonal"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovDiagonal</span></code></a></p>
<p>Uncorrelated (diagonal) noise covariance</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIdentity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Identity noise covariance.</p>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIdentity.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIdentity.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to
fit this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIdentity.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovIdentity.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIdentity.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIdentity.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIsotropic">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovIsotropic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIsotropic" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Scaled identity (isotropic) noise covariance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em>) – size of covariance matrix</p></li>
<li><p><strong>var</strong> (<em>float</em><em> or </em><em>None</em>) – initial value of new variance parameter (if None, initialize randomly)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIsotropic.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIsotropic.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to fit
this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIsotropic.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovIsotropic.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovIsotropic.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovIsotropic.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>tf.Tensor</em>) – Tensor to multiply by inverse of this covariance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovKroneckerFactored">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovKroneckerFactored</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovKroneckerFactored" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Kronecker product noise covariance parameterized in terms
of its component cholesky factors</p>
<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovKroneckerFactored.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovKroneckerFactored.L" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovKroneckerFactored.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovKroneckerFactored.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized
to fit this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovKroneckerFactored.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovKroneckerFactored.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log|Sigma| using the diagonals of the cholesky factors.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovKroneckerFactored.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovKroneckerFactored.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span> using traingular solves with the cholesky
factors.</p>
<p>Specifically, we solve <span class="math notranslate nohighlight">\(L L^T x = y\)</span> by solving
<span class="math notranslate nohighlight">\(L z = y\)</span> and <span class="math notranslate nohighlight">\(L^T x = z\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>tf.Tensor</em>) – Tensor to multiply by inverse of this covariance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholesky">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovUnconstrainedCholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Unconstrained noise covariance parameterized in terms of its cholesky</p>
<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholesky.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky.L" title="Permalink to this definition"></a></dt>
<dd><p>Cholesky factor of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholesky.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to fit
this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholesky.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholesky.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span> (using cholesky solve)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>tf.Tensor</em>) – Tensor to multiply by inverse of this covariance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedCholeskyWishartReg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovUnconstrainedCholeskyWishartReg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedCholeskyWishartReg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovUnconstrainedCholesky" title="brainiak.matnormal.covs.CovUnconstrainedCholesky"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovUnconstrainedCholesky</span></code></a></p>
<p>Unconstrained noise covariance parameterized in terms of its
cholesky factor. Regularized using the trick from
Chung et al. 2015 such that as the covariance approaches
singularity, the likelihood goes to 0.</p>
<p class="rubric">References</p>
<p>Chung, Y., Gelman, A., Rabe-Hesketh, S., Liu, J., &amp; Dorie, V. (2015).
Weakly Informative Prior for Point Estimation of Covariance Matrices
in Hierarchical Models. Journal of Educational and Behavioral Statistics,
40(2), 136–157. <a class="reference external" href="https://doi.org/10.3102/1076998615570945">https://doi.org/10.3102/1076998615570945</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedInvCholesky">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.covs.</span></span><span class="sig-name descname"><span class="pre">CovUnconstrainedInvCholesky</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">invSigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedInvCholesky" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovBase</span></code></a></p>
<p>Unconstrained noise covariance parameterized
in terms of its precision cholesky. Use this over the
regular cholesky unless you have a good reason not to, since
this saves a cholesky solve on every step of optimization</p>
<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedInvCholesky.Linv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Linv</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedInvCholesky.Linv" title="Permalink to this definition"></a></dt>
<dd><p>Inverse of Cholesky factor of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedInvCholesky.get_optimize_vars">
<span class="sig-name descname"><span class="pre">get_optimize_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedInvCholesky.get_optimize_vars" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of tf variables that need to get optimized to fit
this covariance</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedInvCholesky.logdet">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">logdet</span></span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedInvCholesky.logdet" title="Permalink to this definition"></a></dt>
<dd><p>log determinant of this covariance</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.covs.CovUnconstrainedInvCholesky.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.covs.CovUnconstrainedInvCholesky.solve" title="Permalink to this definition"></a></dt>
<dd><p>Given this covariance <span class="math notranslate nohighlight">\(\Sigma\)</span> and some input <span class="math notranslate nohighlight">\(X\)</span>,
compute <span class="math notranslate nohighlight">\(\Sigma^{-1}x\)</span> (using cholesky solve)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>tf.Tensor</em>) – Tensor to multiply by inverse of this covariance</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainiak.matnormal.matnormal_likelihoods">
<span id="brainiak-matnormal-matnormal-likelihoods-module"></span><h2>brainiak.matnormal.matnormal_likelihoods module<a class="headerlink" href="#module-brainiak.matnormal.matnormal_likelihoods" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.matnorm_logp">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">matnorm_logp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.matnorm_logp" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood for centered matrix-variate normal density.
Assumes that row_cov and col_cov follow the API defined in CovBase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Observation tensor</p></li>
<li><p><strong>row_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Row covariance implementing the CovBase API</p></li>
<li><p><strong>col_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Column Covariance implementing the CovBase API</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.matnorm_logp_conditional_col">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">matnorm_logp_conditional_col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cond</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cond_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.matnorm_logp_conditional_col" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood for centered conditional matrix-variate normal density.</p>
<p>Consider the following partitioned matrix-normal density:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\operatorname{vec}\left[\mathbf{X}_{i j}\right] \\
\operatorname{vec}\left[\mathbf{Y}_{i k}\right]\end{bmatrix}
\sim \mathcal{N}\left(0,\begin{bmatrix} \Sigma_{j} \otimes
\Sigma_{i} &amp; \Sigma_{j k} \otimes \Sigma_{i}\\
\Sigma_{k j} \otimes \Sigma_{i} &amp; \Sigma_{k} \otimes \Sigma_{i}
\end{bmatrix}\right)\end{split}\]</div>
<p>Then we can write the conditional:</p>
<div class="math notranslate nohighlight">
\[\mathbf{X}_{i j} \mid \mathbf{Y}_{i k} \sim \mathcal{M}\
\mathcal{N}\left(0, \Sigma_{i}, \Sigma_{j}-\Sigma_{j k}\
\Sigma_{k}^{-1} \Sigma_{k j}\right)\]</div>
<p>This function efficiently computes the conditionals by unpacking some
info in the covariance classes and then dispatching to
<a class="reference internal" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_conditional" title="brainiak.matnormal.matnormal_likelihoods.solve_det_conditional"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_det_conditional</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Observation tensor</p></li>
<li><p><strong>row_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Row covariance (<span class="math notranslate nohighlight">\(\Sigma_{i}\)</span> in the notation above).</p></li>
<li><p><strong>col_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Column covariance (<span class="math notranslate nohighlight">\(\Sigma_{j}\)</span> in the notation above).</p></li>
<li><p><strong>cond</strong> (<em>tf.Tensor</em>) – Off-diagonal block of the partitioned covariance (<span class="math notranslate nohighlight">\(\Sigma_{jk}\)</span>
in the notation above).</p></li>
<li><p><strong>cond_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Covariance of conditioning variable (<span class="math notranslate nohighlight">\(\Sigma_{k}\)</span> in the
notation above).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.matnorm_logp_conditional_row">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">matnorm_logp_conditional_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cond</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cond_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.matnorm_logp_conditional_row" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood for centered conditional matrix-variate normal density.</p>
<p>Consider the following partitioned matrix-normal density:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}
\operatorname{vec}\left[\mathbf{X}_{i j}\right] \\
\operatorname{vec}\left[\mathbf{Y}_{i k}\right]\end{bmatrix}
\sim \mathcal{N}\left(0,\begin{bmatrix} \Sigma_{j} \otimes
\Sigma_{i} &amp; \Sigma_{j k} \otimes \Sigma_{i}\\
\Sigma_{k j} \otimes \Sigma_{i} &amp; \Sigma_{k} \otimes \Sigma_{i}
\end{bmatrix}\right)\end{split}\]</div>
<p>Then we can write the conditional:</p>
<div class="math notranslate nohighlight">
\[\mathbf{X}^T j i \mid \mathbf{Y}_{k i}^T
\sim \mathcal{M}\
\mathcal{N}\left(0, \Sigma_{j}-\Sigma_{j k} \Sigma_{k}^{-1}
\Sigma_{k j},\
\Sigma_{i}\right)\]</div>
<p>This function efficiently computes the conditionals by unpacking some
info in the covariance classes and then dispatching to
<a class="reference internal" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_conditional" title="brainiak.matnormal.matnormal_likelihoods.solve_det_conditional"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_det_conditional</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Observation tensor</p></li>
<li><p><strong>row_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Row covariance (<span class="math notranslate nohighlight">\(\Sigma_{i}\)</span> in the notation above).</p></li>
<li><p><strong>col_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Column covariance (<span class="math notranslate nohighlight">\(\Sigma_{j}\)</span> in the notation above).</p></li>
<li><p><strong>cond</strong> (<em>tf.Tensor</em>) – Off-diagonal block of the partitioned covariance (<span class="math notranslate nohighlight">\(\Sigma_{jk}\)</span>
in the notation above).</p></li>
<li><p><strong>cond_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Covariance of conditioning variable (<span class="math notranslate nohighlight">\(\Sigma_{k}\)</span> in the
notation above).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.matnorm_logp_marginal_col">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">matnorm_logp_marginal_col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marg_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.matnorm_logp_marginal_col" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood for centered marginal matrix-variate normal density.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}X &amp;\sim \mathcal{MN}(0, R, Q)\\\Y \mid \X &amp;\sim \mathcal{MN}(XA, R, C),\\\Y &amp;\sim \mathcal{MN}(0, R, C + A^TQA)\end{aligned}\end{align} \]</div>
<p>This function efficiently computes the marginals by unpacking some
info in the covariance classes and then dispatching to
<a class="reference internal" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_marginal" title="brainiak.matnormal.matnormal_likelihoods.solve_det_marginal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_det_marginal</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Observation tensor</p></li>
<li><p><strong>row_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Row covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(R\)</span> above).</p></li>
<li><p><strong>col_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Column Covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(C\)</span> above).</p></li>
<li><p><strong>marg</strong> (<em>tf.Tensor</em>) – Marginal factor (<span class="math notranslate nohighlight">\(A\)</span> above).</p></li>
<li><p><strong>marg_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Prior covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(Q\)</span> above).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.matnorm_logp_marginal_row">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">matnorm_logp_marginal_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">marg_cov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.matnorm_logp_marginal_row" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood for marginal centered matrix-variate normal density.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}X &amp;\sim \mathcal{MN}(0, Q, C)\\\Y \mid \X &amp;\sim \mathcal{MN}(AX, R, C),\\\Y &amp;\sim \mathcal{MN}(0, R + AQA^T, C)\end{aligned}\end{align} \]</div>
<p>This function efficiently computes the marginals by unpacking some
info in the covariance classes and then dispatching to
<a class="reference internal" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_marginal" title="brainiak.matnormal.matnormal_likelihoods.solve_det_marginal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">solve_det_marginal</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Observation tensor</p></li>
<li><p><strong>row_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Row covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(R\)</span> above).</p></li>
<li><p><strong>col_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Column Covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(C\)</span> above).</p></li>
<li><p><strong>marg</strong> (<em>tf.Tensor</em>) – Marginal factor (<span class="math notranslate nohighlight">\(A\)</span> above).</p></li>
<li><p><strong>marg_cov</strong> (<a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Prior covariance implementing the CovBase API (<span class="math notranslate nohighlight">\(Q\)</span> above).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.solve_det_conditional">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">solve_det_conditional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_conditional" title="Permalink to this definition"></a></dt>
<dd><p>Use matrix inversion lemma for the solve:</p>
<div class="math notranslate nohighlight">
\[(\Sigma - AQ^{-1}A^T)^{-1} X =\
(\Sigma^{-1} + \Sigma^{-1} A (Q -
A^T \Sigma^{-1} A)^{-1} A^T \Sigma^{-1}) X\]</div>
<p>Use matrix determinant lemma for determinant:</p>
<div class="math notranslate nohighlight">
\[\log|(\Sigma - AQ^{-1}A^T)| =
\log|Q - A^T \Sigma^{-1} A| - \log|Q| + \log|\Sigma|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Tensor to multiply the solve by</p></li>
<li><p><strong>sigma</strong> (<em>brainiak.matnormal.CovBase</em>) – Covariance object implementing solve and logdet</p></li>
<li><p><strong>A</strong> (<em>tf.Tensor</em>) – Factor multiplying the variable we conditioned on</p></li>
<li><p><strong>Q</strong> (<em>brainiak.matnormal.CovBase</em>) – Covariance object of conditioning variable,
implementing solve and logdet</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.matnormal_likelihoods.solve_det_marginal">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.matnormal_likelihoods.</span></span><span class="sig-name descname"><span class="pre">solve_det_marginal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.matnormal_likelihoods.solve_det_marginal" title="Permalink to this definition"></a></dt>
<dd><p>Use matrix inversion lemma for the solve:</p>
<div class="math notranslate nohighlight">
\[(\Sigma + AQA^T)^{-1} X =\
(\Sigma^{-1} - \Sigma^{-1} A (Q^{-1} +
A^T \Sigma^{-1} A)^{-1} A^T \Sigma^{-1}) X\]</div>
<p>Use matrix determinant lemma for determinant:</p>
<div class="math notranslate nohighlight">
\[\log|(\Sigma + AQA^T)| = \log|Q^{-1} + A^T \Sigma^{-1} A|
+ \log|Q| + \log|\Sigma|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tf.Tensor</em>) – Tensor to multiply the solve by</p></li>
<li><p><strong>sigma</strong> (<em>brainiak.matnormal.CovBase</em>) – Covariance object implementing solve and logdet</p></li>
<li><p><strong>A</strong> (<em>tf.Tensor</em>) – Factor multiplying the variable we marginalized out</p></li>
<li><p><strong>Q</strong> (<em>brainiak.matnormal.CovBase</em>) – Covariance object of marginalized variable,
implementing solve and logdet</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-brainiak.matnormal.mnrsa">
<span id="brainiak-matnormal-mnrsa-module"></span><h2>brainiak.matnormal.mnrsa module<a class="headerlink" href="#module-brainiak.matnormal.mnrsa" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.mnrsa.MNRSA">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.mnrsa.</span></span><span class="sig-name descname"><span class="pre">MNRSA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_nureg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optCtrl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.mnrsa.MNRSA" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>Matrix normal version of RSA.</p>
<p>The goal of this analysis is to find the covariance of the mapping from
some design matrix X to the fMRI signal Y. It does so by marginalizing over
the actual mapping (i.e. averaging over the uncertainty in it), which
happens to correct a bias imposed by structure in the design matrix on the
RSA estimate (see Cai et al., NIPS 2016).</p>
<p>This implementation makes different choices about residual covariance
relative to <code class="xref py py-obj docutils literal notranslate"><span class="pre">brainiak.reprsimil.BRSA</span></code>: Here, the noise covariance is
assumed to be kronecker-separable. Informally, this means that all voxels
have the same temporal covariance, and all time points have the same
spatial covariance. This is in contrast to BRSA, which allows different
temporal covariance for each voxel. On the other hand, computational
efficiencies enabled by this choice allow MNRSA to support a richer class
of space and time covariances (anything in <a class="reference internal" href="#module-brainiak.matnormal.covs" title="brainiak.matnormal.covs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">brainiak.matnormal.covs</span></code></a>).</p>
<p>For users: in general, if you are worried about voxels each having
different temporal noise structure,you should use
<code class="xref py py-obj docutils literal notranslate"><span class="pre">brainiak.reprsimil.BRSA</span></code>. If you are worried about between-voxel
correlations or temporal covaraince structures that BRSA does not
support, you should use MNRSA.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}Y &amp;\sim \mathcal{MN}(0, \Sigma_t + XLL^TX^T+
X_0X_0^T, \Sigma_s)\\\U &amp;= LL^T\end{aligned}\end{align} \]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_cov</strong> (<em>subclass</em><em> of </em><a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Temporal noise covariance class following CovBase interface.</p></li>
<li><p><strong>space_cov</strong> (<em>subclass</em><em> of </em><a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Spatial noise covariance class following CovBase interface.</p></li>
<li><p><strong>optimizer</strong> (<em>string</em><em>, </em><em>Default :'L-BFGS'</em>) – Name of scipy optimizer to use.</p></li>
<li><p><strong>optCtrl</strong> (<em>dict</em><em>, </em><em>default: None</em>) – Additional arguments to pass to scipy.optimize.minimize.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="brainiak.matnormal.mnrsa.MNRSA.L">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">L</span></span><a class="headerlink" href="#brainiak.matnormal.mnrsa.MNRSA.L" title="Permalink to this definition"></a></dt>
<dd><p>Cholesky factor of the RSA matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.mnrsa.MNRSA.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naive_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.mnrsa.MNRSA.fit" title="Permalink to this definition"></a></dt>
<dd><p>Estimate dimension reduction and cognitive model parameters</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2d array</em>) – Brain data matrix (TRs by voxels). Y in the math</p></li>
<li><p><strong>y</strong> (<em>2d array</em><em> or </em><em>vector</em>) – Behavior data matrix (TRs by behavioral obsevations). X in the math</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>default=1000</em>) – Maximum number of iterations to run</p></li>
<li><p><strong>step</strong> (<em>int</em><em>, </em><em>default=100</em>) – Number of steps between optimizer output</p></li>
<li><p><strong>restart</strong> (<em>bool</em><em>, </em><em>default=True</em>) – If this is true, optimizer is restarted (e.g. for a new dataset).
Otherwise optimizer will continue from where it is now (for example
for running more iterations if the initial number was not enough).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.mnrsa.MNRSA.logp">
<span class="sig-name descname"><span class="pre">logp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.mnrsa.MNRSA.logp" title="Permalink to this definition"></a></dt>
<dd><p>MNRSA Log-likelihood</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.mnrsa.MNRSA.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naive_init</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brainiak.matnormal.mnrsa.MNRSA" title="brainiak.matnormal.mnrsa.MNRSA"><span class="pre">MNRSA</span></a></span></span><a class="headerlink" href="#brainiak.matnormal.mnrsa.MNRSA.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>naive_init</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">naive_init</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainiak.matnormal.regression">
<span id="brainiak-matnormal-regression-module"></span><h2>brainiak.matnormal.regression module<a class="headerlink" href="#module-brainiak.matnormal.regression" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.regression.</span></span><span class="sig-name descname"><span class="pre">MatnormalRegression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_cov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L-BFGS-B'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optCtrl</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">BaseEstimator</span></code></p>
<p>This analysis allows maximum likelihood estimation of regression models
in the presence of both spatial and temporal covariance.</p>
<dl class="simple">
<dt>..math::</dt><dd><p>Y sim mathcal{MN}(Xeta, time_cov, space_cov)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_cov</strong> (<em>subclass</em><em> of </em><a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – TR noise covariance class following CovBase interface.</p></li>
<li><p><strong>space_cov</strong> (<em>subclass</em><em> of </em><a class="reference internal" href="#brainiak.matnormal.covs.CovBase" title="brainiak.matnormal.covs.CovBase"><em>CovBase</em></a>) – Voxel noise covariance class following CovBase interface.</p></li>
<li><p><strong>optimizer</strong> (<em>string</em><em>, </em><em>default=&quot;L-BFGS-B&quot;</em>) – Scipy optimizer to use. For other options, see “method” argument
of scipy.optimize.minimize</p></li>
<li><p><strong>optCtrl</strong> (<em>dict</em><em>, </em><em>default=None</em>) – Additional arguments to pass to scipy.optimize.minimize.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression.calibrate">
<span class="sig-name descname"><span class="pre">calibrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression.calibrate" title="Permalink to this definition"></a></dt>
<dd><p>Decode design matrix from fMRI dataset, based on a previously
trained mapping. This method just does naive MLE:</p>
<div class="math notranslate nohighlight">
\[X = Y \Sigma_s^{-1}B^T(B \Sigma_s^{-1} B^T)^{-1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Y</strong> (<em>np.array</em><em>, </em><em>TRs by voxels.</em>) – fMRI dataset</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naive_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression.fit" title="Permalink to this definition"></a></dt>
<dd><p>Compute the regression fit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>np.array</em><em>, </em><em>TRs by conditions.</em>) – Design matrix</p></li>
<li><p><strong>y</strong> (<em>np.array</em><em>, </em><em>TRs by voxels.</em>) – fMRI data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression.logp">
<span class="sig-name descname"><span class="pre">logp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression.logp" title="Permalink to this definition"></a></dt>
<dd><p>Log likelihood of model (internal)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict fMRI signal from design matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>X</strong> (<em>np.array</em><em>, </em><em>TRs by conditions.</em>) – Design matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brainiak.matnormal.regression.MatnormalRegression.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">naive_init</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brainiak.matnormal.regression.MatnormalRegression" title="brainiak.matnormal.regression.MatnormalRegression"><span class="pre">MatnormalRegression</span></a></span></span><a class="headerlink" href="#brainiak.matnormal.regression.MatnormalRegression.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>naive_init</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">naive_init</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-brainiak.matnormal.utils">
<span id="brainiak-matnormal-utils-module"></span><h2>brainiak.matnormal.utils module<a class="headerlink" href="#module-brainiak.matnormal.utils" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.flatten_cholesky_unique">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">flatten_cholesky_unique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.flatten_cholesky_unique" title="Permalink to this definition"></a></dt>
<dd><p>Flattens nonzero-elements Cholesky (triangular) factor
into a vector, and logs diagonal to make parameterization
unique. Inverse of unflatten_cholesky_unique.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.make_val_and_grad">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">make_val_and_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lossfn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_vars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.make_val_and_grad" title="Permalink to this definition"></a></dt>
<dd><p>Makes a function that ouptuts the loss and gradient in a format compatible
with scipy.optimize.minimize</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.pack_trainable_vars">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">pack_trainable_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trainable_vars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.pack_trainable_vars" title="Permalink to this definition"></a></dt>
<dd><p>Pack trainable vars in a model into a single
vector that can be passed to scipy.optimize</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.rmn">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">rmn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rowcov</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colcov</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.rmn" title="Permalink to this definition"></a></dt>
<dd><p>Generate random draws from a zero-mean matrix-normal distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rowcov</strong> (<em>np.ndarray</em>) – Row covariance (assumed to be positive definite)</p></li>
<li><p><strong>colcov</strong> (<em>np.ndarray</em>) – Column covariance (assumed to be positive definite)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.scaled_I">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">scaled_I</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.scaled_I" title="Permalink to this definition"></a></dt>
<dd><p>Scaled identity matrix
<span class="math notranslate nohighlight">\(x I_{size}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em><em> or </em><em>coercable to float</em>) – Scale to multiply the identity matrix by</p></li>
<li><p><strong>size</strong> (<em>int</em><em> or </em><em>otherwise coercable to a size</em>) – Dimension of the scaled identity matrix to return</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.unflatten_cholesky_unique">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">unflatten_cholesky_unique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">L_flat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.unflatten_cholesky_unique" title="Permalink to this definition"></a></dt>
<dd><p>Converts a vector of elements into a triangular matrix
(Cholesky factor). Exponentiates diagonal to make
parameterization unique. Inverse of flatten_cholesky_unique.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.unpack_trainable_vars">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">unpack_trainable_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trainable_vars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.unpack_trainable_vars" title="Permalink to this definition"></a></dt>
<dd><p>Unpack trainable vars from a single vector as
used/returned by scipy.optimize</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.x_tx">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">x_tx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.x_tx" title="Permalink to this definition"></a></dt>
<dd><p>Inner product
<span class="math notranslate nohighlight">\(x^T x\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>tf.Tensor</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brainiak.matnormal.utils.xx_t">
<span class="sig-prename descclassname"><span class="pre">brainiak.matnormal.utils.</span></span><span class="sig-name descname"><span class="pre">xx_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brainiak.matnormal.utils.xx_t" title="Permalink to this definition"></a></dt>
<dd><p>Outer product
<span class="math notranslate nohighlight">\(xx^T\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>tf.Tensor</em>) – </p>
</dd>
</dl>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="brainiak.hyperparamopt.html" class="btn btn-neutral float-left" title="brainiak.hyperparamopt package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="brainiak.reconstruct.html" class="btn btn-neutral float-right" title="brainiak.reconstruct package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016, Princeton Neuroscience Institute and Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>